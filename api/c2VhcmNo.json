[{"title":"CSS 实现表格的首行首列吸顶","date":"2021-02-27T14:54:34.000Z","date_formatted":{"ll":"Feb 27, 2021","L":"02/27/2021","MM-DD":"02-27"},"updated":"2021-02-27T15:33:12.340Z","content":"背景\n最近在对现有的页面进行优化。\n发现之前页面中表格的首行首列吸顶效果是由 js 在 onscroll 中计算 top 和 left 的数值实现的。\nCSS 的实现方法\n通过谷歌发现一个通过 position: sticky 和 table-layout: fixed 配合 table 的实现方法非常巧妙。\n这里利用 position: sticky 和 width: max-content 配合 div 实现吸顶的效果。\n效果如下：\n\n    .main {\n        width: 500px;\n        height: 280px;\n        overflow-x: scroll;\n        overflow-y: scroll;\n    }\n    .head,\n    .row {\n        width: max-content;\n    }\n    .head {\n        position: sticky;\n        top: 0;\n        z-index: 2;\n    }\n    .col {\n        display: inline-block;\n        border: 1px solid #5f5f5f;\n        width: 100px;\n        height: 40px;\n    }\n    .head .col {\n        background-color: cornflowerblue;\n    }\n    .head .col:first-child {\n        position: sticky;\n        left: 0;\n        background-color: aquamarine;\n        z-index: 1;\n    }\n    .row .col:first-child {\n        position: sticky;\n        left: 0;\n        z-index: 1;\n        background-color: palegoldenrod;\n    }\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n\n附上 demo 代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style&gt;    .main &#123;        width: 500px;        height: 280px;        overflow-x: scroll;        overflow-y: scroll;    &#125;    .head,    .row &#123;        width: max-content;    &#125;    .head &#123;        position: sticky;        top: 0;        z-index: 2;    &#125;    .col &#123;        display: inline-block;        border: 1px solid #5f5f5f;        width: 100px;        height: 40px;    &#125;    .head .col &#123;        background-color: cornflowerblue;    &#125;    .head .col:first-child &#123;        position: sticky;        left: 0;        background-color: aquamarine;        z-index: 1;    &#125;    .row .col:first-child &#123;        position: sticky;        left: 0;        z-index: 1;        background-color: palegoldenrod;    &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;head&quot;&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;template v-for=&quot;n in 10&quot;&gt;        &lt;div class=&quot;row&quot; :key=&quot;n&quot;&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;&lt;/div&gt;","plink":"https://syaki.github.io/2021/02/27/CSS-实现表格的首行首列吸顶/"},{"title":"Practical application of Cartesian product","date":"2020-08-17T06:31:06.000Z","date_formatted":{"ll":"Aug 17, 2020","L":"08/17/2020","MM-DD":"08-17"},"updated":"2021-02-19T13:58:52.295Z","content":"JavaScript 使用 Array.flagMap() 方法实现笛卡尔乘积\n12345const a = [&#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;a3&#x27;];const b = [&#x27;b1&#x27;, &#x27;b2&#x27;, &#x27;b3&#x27;];console.log(a.flatMap((x1) =&gt; b.map((x2) =&gt; x1 + x2)));// Array(9) [ &quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;, &quot;a3b1&quot;, &quot;a3b2&quot;, &quot;a3b3&quot; ]\nJava 利用笛卡尔乘积实现中文姓名拼音校验\n由于中文存在多音字的情况，对于每个字可能的拼音求笛卡尔积。\n接口定义\n123public interface IChineseNamePinyin &#123;    boolean verifyChineseNamePinyin(String name, String pinyin);&#125;\n具体实现\n利用 Java 8 Stream flatMap() 方法对姓名中每个字可能的拼音求笛卡尔积。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ChineseNamePinyinImpl implements IChineseNamePinyin &#123;    /**     * 中文姓名拼音校验     * @param name   姓名     * @param pinyin 拼音     * @return 中文姓名拼音校验结果     */    @Override    public boolean verifyChineseNamePinyin(String name, String pinyin) &#123;        if (StringUtils.isNullOrEmpty(name) || StringUtils.isNullOrEmpty(pinyin)) return false;        // 初始化 pinyin4j format        HanyuPinyinOutputFormat format = new HanyuPinyinOutputFormat();        format.setCaseType(HanyuPinyinCaseType.LOWERCASE);        format.setToneType(HanyuPinyinToneType.WITHOUT_TONE);        format.setVCharType(HanyuPinyinVCharType.WITH_V);        // 将姓名转为 char array        char[] nameChars = name.trim().toCharArray();        List&lt;List&lt;String&gt;&gt; nameCharPinyinList = Lists.newLinkedList();        List&lt;String&gt; namePinyinList = Lists.newLinkedList();        namePinyinList.add(&quot;&quot;);        try &#123;            for (char nameChar : nameChars) &#123;                // 过滤非中文字符                if (!Character.toString(nameChar).matches(&quot;[\\\\u4E00-\\\\u9FA5]+&quot;)) continue;                // 统计多音字所有的拼音                nameCharPinyinList.add(this.nameCharToHanyuPinyinStringList(nameChar, format));            &#125;        &#125; catch (Exception e) &#123;            return false;        &#125;        // 将所有拼音的组合收集成一个 list        for (List&lt;String&gt; strings : nameCharPinyinList) &#123;            namePinyinList = namePinyinList.stream()                    .flatMap(r -&gt; strings.stream()                            .map(c -&gt; r + c))                    .collect(Collectors.toList());        &#125;        // 判断拼音是否匹配        return namePinyinList.contains(pinyin);    &#125;    /**     * 调用 PinyinHelper 获取拼音     */    private List&lt;String&gt; nameCharToHanyuPinyinStringList(char nameChar, HanyuPinyinOutputFormat format) throws Exception &#123;        return Arrays.asList(PinyinHelper.toHanyuPinyinStringArray(nameChar, format));    &#125;&#125;","plink":"https://syaki.github.io/2020/08/17/Practical-application-of-Cartesian-product/"},{"title":"How to debug rust","date":"2019-11-04T04:58:31.000Z","date_formatted":{"ll":"Nov 4, 2019","L":"11/04/2019","MM-DD":"11-04"},"updated":"2021-01-30T07:14:12.065Z","content":"Windows\nInstall msys2\nRun mingw64.exe\n\n\nedit source\nmsys64/etc/pacman.d/\n12345678mirrorlist.mingw32Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;i686mirrorlist.mingw64Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;x86_64mirrorlist.msysServer &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;msys&#x2F;$arch\n\n\nrun command\n1pacman -S --noconfirm base-devel mingw64-x86_64-toolchain git\n\n\nAdd cargo config\nedit &#123;PATH&#125;/.cargo/config\nadd this:\n123[target.x86_64-pc-windows-gnu]linker &#x3D; &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\gcc.exe&quot;ar &#x3D; &quot;C:\\\\msys2\\\\mingw64\\\\bin\\\\ar.exe&quot;\nAdd PATH environmental variable\nC:\\msys64\\usr\\bin\nC:\\msys64\\mingw64\\bin\nInstall rust\nuse stable-gnu\n12rustup install stable-gnurustup default stable-gnu\nInstall CLion\n\n\ninstall intellij-rust and toml plugin\n\n\nset toolchain\nFile -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Toolchains add mingw toolchain\n\n\nmacOS\nInstall Command Line Tools or xcode.\nInstall rust, clion and intellij-rust plugin.\n","plink":"https://syaki.github.io/2019/11/04/How-to-debug-rust/"},{"title":"The Tiny Compiler","date":"2019-10-08T02:46:27.000Z","date_formatted":{"ll":"Oct 8, 2019","L":"10/08/2019","MM-DD":"10-08"},"updated":"2021-01-30T07:14:12.067Z","content":"A super tiny compiler\nThis file would only be ~200 lines of actual code. source code\n这个文件大概只有200行代码。\nWe’re going to compile some lisp-like function calls into some C-like function calls.\n我们将把一些类似 lisp 的方法调用编译为类似 C 的方法调用。\nIf we had two functions add and subtract they would be written like this:\n如果我们有两个方法 add 和 subtract，他们将被写成这样：\n12345               LISP                      C2 + 2          (add 2 2)                 add(2, 2)4 - 2          (subtract 4 2)            subtract(4, 2)2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))\nMost compilers break down into three primary stages: Parsing, Transformation, and Code Generation\n大多数编译器主要分为三个阶段：解析、转换和代码生成\n\n\nParsing is taking raw code and turning it into a more abstract representation of the code.\nParsing 是将原始代码转化为抽象代码表现形式。\n\n\nTransformation takes this abstract representation and manipulates to do whatever the compiler wants it to.\nTransformation 接受抽象表示并按照编译器的要求操作。\n\n\nCode Generation takes the transformed representation of the code and turns it into new code.\nCode Generation 根据转化后的抽象代码表现形式生产新的代码。\n\n\nParsing\nParsing typically gets broken down into two phases: Lexical Analysis and Syntactic Analysis.\n解析通常分为两个阶段：词法分析和句法分析。\n\n\nLexical Analysis takes the raw code and splits it apart into these things called tokens by a thing called a tokenizer (or lexer).\nLexical Analysis 获取原始代码，并将其分解为由记号赋予器（或lexer）组成的记号。\nTokens are an array of tiny little objects that describe an isolated piece of the syntax. They could be numbers, labels, punctuation, operators, whatever.\n令牌是一组微小的对象，它们描述了一个孤立的语法片段。它们可以是数字、标签、标点符号、操作符等等。\n\n\nSyntactic Analysis takes the tokens and reformats them into a representation that describes each part of the syntax and their relation to one another. This is known as an intermediate representation or Abstract Syntax Tree.\nSyntactic Analysis 获取标记并将它们重新格式化为一个表示，该表示描述了语法的每个部分以及它们之间的关系。这就是所谓的中间表示或抽象语法树。\nAn Abstract Syntax Tree, or AST for short, is a deeply nested object that represents code in a way that is both easy to work with and tells us a lot of information.\n抽象语法树，简称AST，是一种嵌套很深的对象，它以一种既易于使用又能告诉我们很多信息的方式表示代码。\n\n\nFor the following syntax:\n(add 2 (subtract 4 2))\n\nTokens might look something like this:\n1234567891011[    &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,    &#123; type: &#x27;name&#x27;,   value: &#x27;add&#x27;      &#125;,    &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,    &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,    &#123; type: &#x27;name&#x27;,   value: &#x27;subtract&#x27; &#125;,    &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27;        &#125;,    &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,    &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,    &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,]\nAnd an Abstract Syntax Tree (AST) might look like this:\n123456789101112131415161718192021&#123;    type: &#x27;Program&#x27;,    body: [&#123;        type: &#x27;CallExpression&#x27;,        name: &#x27;add&#x27;,        params: [&#123;            type: &#x27;NumberLiteral&#x27;,            value: &#x27;2&#x27;,        &#125;, &#123;            type: &#x27;CallExpression&#x27;,            name: &#x27;subtract&#x27;,            params: [&#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;4&#x27;,            &#125;, &#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;2&#x27;,            &#125;]        &#125;]    &#125;]&#125;\nTransformation\nThe next type of stage for a compiler is transformation. Again, this just takes the AST from the last step and makes changes to it. It can manipulate the AST in the same language or it can translate it into an entirely new language.\n编译器的下一个阶段是转换。同样，这只是从最后一步获取AST并对其进行更改。它可以在同一种语言中操作AST，也可以将它翻译成一种全新的语言。\nYou might notice that our AST has elements within it that look very similar. There are these objects with a type property. Each of these are known as an AST Node. These nodes have defined properties on them that describe one isolated part of the tree.\n您可能会注意到，AST中的元素看起来非常相似。这些对象具有type属性。每个节点都称为AST节点。这些节点上定义了描述树的一个独立部分的属性。\nWe can have a node for a “NumberLiteral”:\n1234&#123;    type: &#x27;NumberLiteral&#x27;,    value: &#x27;2&#x27;,&#125;\nOr maybe a node for a “CallExpression”:\n12345&#123;    type: &#x27;CallExpression&#x27;,    name: &#x27;subtract&#x27;,    params: [...nested nodes go here...],&#125;\nWhen transforming the AST we can manipulate nodes by adding/removing/replacing properties, we can add new nodes, remove nodes, or we could leave the existing AST alone and create an entirely new one based on it.\n在转换AST时，我们可以通过添加/删除/替换属性来操作节点，我们可以添加新节点，删除节点，或者我们可以不使用现有的AST并基于它创建一个全新的AST。\nSince we’re targeting a new language, we’re going to focus on creating an entirely new AST that is specific to the target language.\n由于我们的目标是一种新语言，所以我们将重点创建一个针对目标语言的全新AST。\nTraversal\nIn order to navigate through all of these nodes, we need to be able to traverse through them. This traversal process goes to each node in the AST depth-first.\n为了浏览所有这些节点，我们需要能够遍历它们。这个遍历过程首先遍历AST深度第一的每个节点。\n123456789101112131415161718192021&#123;    type: &#x27;Program&#x27;,    body: [&#123;        type: &#x27;CallExpression&#x27;,        name: &#x27;add&#x27;,        params: [&#123;            type: &#x27;NumberLiteral&#x27;,            value: &#x27;2&#x27;        &#125;, &#123;            type: &#x27;CallExpression&#x27;,            name: &#x27;subtract&#x27;,            params: [&#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;4&#x27;            &#125;, &#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;2&#x27;            &#125;]        &#125;]    &#125;]&#125;\nSo for the above AST we would go:\n\n\nProgram - Starting at the top level of the AST\n从AST的顶层开始\n\n\nCallExpression (add) - Moving to the first element of the Program’s body\n移动到程序主体的第一个元素\n\n\nNumberLiteral (2) - Moving to the first element of CallExpression’s params\n移动到CallExpression的参数的第一个元素\n\n\nCallExpression (subtract) - Moving to the second element of CallExpression’s params\n移动到CallExpression的参数的第二个元素\n\n\nNumberLiteral (4) - Moving to the first element of CallExpression’s params\n移动到CallExpression的参数的第一个元素\n\n\nNumberLiteral (2) - Moving to the second element of CallExpression’s params\n移动到CallExpression的参数的第二个元素\n\n\nIf we were manipulating this AST directly, instead of creating a separate AST, we would likely introduce all sorts of abstractions here. But just visiting each node in the tree is enough for what we’re trying to do.\n如果我们直接操作这个AST，而不是创建一个单独的AST，我们可能会在这里引入各种各样的抽象。但只要访问树中的每个节点就足够了。\nThe reason I use the word “visiting” is because there is this pattern of how to represent operations on elements of an object structure.\n我之所以使用“访问”这个词，是因为存在这样一种模式，即如何表示对象结构元素上的操作。\nVisitors\nThe basic idea here is that we are going to create a “visitor” object that has methods that will accept different node types.\n这里的基本思想是，我们将创建一个“visitor”对象，该对象的方法将接受不同的节点类型。\n1234var visitor = &#123;    NumberLiteral() &#123;&#125;,    CallExpression() &#123;&#125;,&#125;;\nWhen we traverse our AST, we will call the methods on this visitor whenever we “enter” a node of a matching type.\n当我们遍历AST时，每当我们“输入”一个匹配类型的节点时，就会调用这个访问器上的方法。\nIn order to make this useful we will also pass the node and a reference to the parent node.\n为了使其有用，我们还将把节点和引用传递给父节点。\n1234var visitor = &#123;    NumberLiteral(node, parent) &#123;&#125;,    CallExpression(node, parent) &#123;&#125;,&#125;;\nHowever, there also exists the possibility of calling things on “exit”. Imagine our tree structure from before in list form:\n但是，也存在调用“exit”的可能性。想象一下我们的树结构，从以前的列表形式:\n123456- Program    - CallExpression        - NumberLiteral        - CallExpression            - NumberLiteral            - NumberLiteral\nAs we traverse down, we’re going to reach branches with dead ends. As we finish each branch of the tree we “exit” it. So going down the tree we “enter” each node, and going back up we “exit”.\n当我们向下走的时候，我们会到达一些没有树枝的尽头。当我们完成树的每个分支时，我们“退出”它。因此，沿着树向下，我们“输入”每个节点，然后向上，我们“退出”每个节点。\n123456789101112-&gt; Program (enter)    -&gt; CallExpression (enter)        -&gt; Number Literal (enter)        &lt;- Number Literal (exit)        -&gt; Call Expression (enter)            -&gt; Number Literal (enter)            &lt;- Number Literal (exit)            -&gt; Number Literal (enter)            &lt;- Number Literal (exit)        &lt;- CallExpression (exit)    &lt;- CallExpression (exit)&lt;- Program (exit)\nIn order to support that, the final form of our visitor will look like this:\n为了支持这一点，我们的访问者的最终形式将是这样的:\n123456var visitor = &#123;    NumberLiteral: &#123;        enter(node, parent) &#123;&#125;,        exit(node, parent) &#123;&#125;,    &#125;&#125;;\nCode Generation\nThe final phase of a compiler is code generation. Sometimes compilers will do things that overlap with transformation, but for the most part code generation just means take our AST and string-ify code back out.\n编译器的最后阶段是代码生成。有时编译器会做一些与转换重叠的事情，但大多数情况下，代码生成只是意味着将AST和string-ify代码拿出来。\nCode generators work several different ways, some compilers will reuse the tokens from earlier, others will have created a separate representation of the code so that they can print node linearly, but from what I can tell most will use the same AST we just created, which is what we’re going to focus on.\n代码生成器有几种不同的方式工作，一些编译器将重用令牌，其它的将会创建一个单独的代码表示，这样他们就可以打印节点线性，但我可以说大部分都使用我们刚刚创建的相同的AST，这是我们要关注的。\nEffectively our code generator will know how to “print” all of the different node types of the AST, and it will recursively call itself to print nested nodes until everything is printed into one long string of code.\n实际上，我们的代码生成器将知道如何“打印”AST的所有不同节点类型，它将递归地调用自身来打印嵌套节点，直到所有内容都打印到一个长串代码中。\n","plink":"https://syaki.github.io/2019/10/08/The-Tiny-Compiler/"},{"title":"How to use Xi-editor?","date":"2019-05-08T06:38:05.000Z","date_formatted":{"ll":"May 8, 2019","L":"05/08/2019","MM-DD":"05-08"},"updated":"2021-01-30T07:14:12.065Z","content":"\nWhat is Xi-editor?\nThe xi-editor project is an attempt to build a high quality text editor, using modern software engineering techniques.\nInstall it on macOS\nRequirements\n\n\nXcode 10.2\n\n\nRust\n\n\nInstalling\nClone the repository:\n12git clone --recurse-submodules https://github.com/xi-editor/xi-maccd xi-mac\nBuild and Open:\n1xcodebuild\nXiEditor.app in ./build/Release/\nMove to Applications Folder:\ndrag to Application folder\n1cp -r Build/Release/XiEditor.app /Applications\nCLI\ninstalling\n\n\nOpen XiEditor\n\n\nXiEditor &gt; Install Command Line Tool\n\n\nInstall theme\nDownload theme file\ndracula for sublime\nMove to :\nfind /Users/username/Library/Application\\ Support/XiEditor/themes/\ndrag Dracula.tmTheme to it\nChange theme\nA theme can be selected from the Debug &gt; Theme menu. There is not yet a mechanism for including custom themes.\nConfiguration\nthe general preferences are located at ~/Library/Application Support/XiEditor/preferences.xiconfig. This file can be opened from File &gt; Preferences (⌘ + ,).\nInstall plugin\nDownload plugin\nWord Count Plugin for Xi-editor\nInstallation\nunzip /Users/huixie/Library/Application\\ Support/XiEditor/plugins/\ndrag xi-mac folder to it\ngo to plugin folder\n1make install\nopen Xi-editor，Debug &gt; Plugin start\n\nOther plugin\nSearch xi-editor plugin in Github.\n","plink":"https://syaki.github.io/2019/05/08/How-to-use-Xi-editor/"}]