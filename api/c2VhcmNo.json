[{"title":"CSS 实现表格的首行首列吸顶","date":"2021-02-27T14:54:34.000Z","date_formatted":{"ll":"Feb 27, 2021","L":"02/27/2021","MM-DD":"02-27"},"updated":"2021-02-27T15:33:12.340Z","content":"背景\n最近在对现有的页面进行优化。\n发现之前页面中表格的首行首列吸顶效果是由 js 在 onscroll 中计算 top 和 left 的数值实现的。\nCSS 的实现方法\n通过谷歌发现一个通过 position: sticky 和 table-layout: fixed 配合 table 的实现方法非常巧妙。\n这里利用 position: sticky 和 width: max-content 配合 div 实现吸顶的效果。\n效果如下：\n\n    .main {\n        width: 500px;\n        height: 280px;\n        overflow-x: scroll;\n        overflow-y: scroll;\n    }\n    .head,\n    .row {\n        width: max-content;\n    }\n    .head {\n        position: sticky;\n        top: 0;\n        z-index: 2;\n    }\n    .col {\n        display: inline-block;\n        border: 1px solid #5f5f5f;\n        width: 100px;\n        height: 40px;\n    }\n    .head .col {\n        background-color: cornflowerblue;\n    }\n    .head .col:first-child {\n        position: sticky;\n        left: 0;\n        background-color: aquamarine;\n        z-index: 1;\n    }\n    .row .col:first-child {\n        position: sticky;\n        left: 0;\n        z-index: 1;\n        background-color: palegoldenrod;\n    }\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n\n附上 demo 代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style&gt;    .main &#123;        width: 500px;        height: 280px;        overflow-x: scroll;        overflow-y: scroll;    &#125;    .head,    .row &#123;        width: max-content;    &#125;    .head &#123;        position: sticky;        top: 0;        z-index: 2;    &#125;    .col &#123;        display: inline-block;        border: 1px solid #5f5f5f;        width: 100px;        height: 40px;    &#125;    .head .col &#123;        background-color: cornflowerblue;    &#125;    .head .col:first-child &#123;        position: sticky;        left: 0;        background-color: aquamarine;        z-index: 1;    &#125;    .row .col:first-child &#123;        position: sticky;        left: 0;        z-index: 1;        background-color: palegoldenrod;    &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;head&quot;&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;template v-for=&quot;n in 10&quot;&gt;        &lt;div class=&quot;row&quot; :key=&quot;n&quot;&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;col&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;&lt;/div&gt;","plink":"https://syaki.github.io/2021/02/27/CSS-实现表格的首行首列吸顶/"},{"title":"GitLab CD/CD 实践","date":"2020-10-21T15:06:51.000Z","date_formatted":{"ll":"Oct 21, 2020","L":"10/21/2020","MM-DD":"10-21"},"updated":"2021-03-02T05:41:38.651Z","content":"\nJavaScript Web 应用的 GitLab CI/CD 配置\nPipeline\nStart -&gt; Install -&gt; Build -&gt; Publish -&gt; Verify -&gt; End\nInstall\n通过 npm install 安装依赖包，并将结果缓存到 cache 里。\n123456script:    - npm install --proxy=$PROXY --https-proxy=$PROXYcache:    key: $CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA    paths:        - node_modules\n如果项目依赖私有 git 仓库和代理。\nSSH_PRIVATE_KEY 和 SSH_KNOWN_HOSTS 为配置好的 GitLab CI/CD 变量。\n123456789101112variables:    PROXY: # proxy link    HTTP_PROXY: $PROXY    HTTPS_PROXY: $PROXYbefore_script:    # 项目依赖 git 私有仓库代码，因此将配置好的私钥存储到当前容器中    - eval $(ssh-agent -s)    - echo &quot;$SSH_PRIVATE_KEY&quot; | tr -d &#x27;\\r&#x27; | ssh-add - &gt; /dev/null    - mkdir -p ~/.ssh    - chmod 700 ~/.ssh    - echo &quot;$SSH_KNOWN_HOSTS&quot; &gt; ~/.ssh/known_hosts    - chmod 644 ~/.ssh.SSH_KNOWN_HOSTS\nBuild\n从缓存中拉取 Install 的结果，运行自定义构建命令并将生成的结果存入 artifacts 。\n123456789101112131415variables:    &lt;&lt;: *node-variables    &lt;&lt;: *organization-variablescache:    key: $CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA    paths:        - node_modules    # 拉取 Install 阶段生成的 node_modules    policy: pullartifacts:    # 将自定义构建后的资源存储到 artifacts 中    paths:        - dist/ # 自定义构建后的资源路径script:    - npm run build # 自定义构建命令\nPublish\n使用构建好的镜像，发布静态资源。\n12image: # 发布静态资源的镜像地址script: publish # 发布命令\nVerify\n一些自动化测试，代码静态分析和代码格式化。\nJava Web 应用的 GitLab CI/CD 配置\nPipeline\nStart -&gt; Complie -&gt; Package -&gt; Image -&gt; Deploy -&gt; End\nComplie\n利用 maven 对代码进行 clean compile ，将 verify-package.yml 报告存入 artifacts ，并将生成的 target 存入 cache 。\n12345678910caches:    - key: compile-cache      paths:          - $POM_DIR/**/target/classes          - $POM_DIR/**/target/generated-sources          - $POM_DIR/**/target/maven-status      policy: pushartifacts:    reports:        snapshot: &#x27;$POM_DIR/**/target/verify-package.yml&#x27;\nPackage\nPackage 依赖 Compile 。\n从 cache 中拉取 compile cache 。并将打包结果存入 cache 。\n12345678910111213141516needs:    - Compilecaches:    - key: compile-cache      paths:          - $POM_DIR/**/target/classes          - $POM_DIR/**/target/generated-sources          - $POM_DIR/**/target/maven-status      policy: pull    - key: $&#123;CACHE_KEY&#125;-target      paths:          - ./**/*.war          - ./**/*.zip      policy: pushscript:    - mvn package\nImage\n利用 package 的 cache 和构建好的基础环境镜像构建应用镜像放入 cache 中。\n123456789101112caches:    - key: $&#123;CACHE_KEY&#125;-target      paths:          - ./**/*.war      policy: pull    - key: $&#123;CACHE_KEY&#125;-image-repo-file      paths:        - $&#123;IMAGE_REPO_FILE&#125;     policy: pushscript:    - docker login    - image build\nDeploy\n拉取 cache 中构建好的应用镜像，发布到机器上。\n","plink":"https://syaki.github.io/2020/10/21/GitLab-CD-CD-实践/"},{"title":"Practical application of Cartesian product","date":"2020-08-17T06:31:06.000Z","date_formatted":{"ll":"Aug 17, 2020","L":"08/17/2020","MM-DD":"08-17"},"updated":"2021-02-19T13:58:52.295Z","content":"JavaScript 使用 Array.flagMap() 方法实现笛卡尔乘积\n12345const a = [&#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;a3&#x27;];const b = [&#x27;b1&#x27;, &#x27;b2&#x27;, &#x27;b3&#x27;];console.log(a.flatMap((x1) =&gt; b.map((x2) =&gt; x1 + x2)));// Array(9) [ &quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;, &quot;a3b1&quot;, &quot;a3b2&quot;, &quot;a3b3&quot; ]\nJava 利用笛卡尔乘积实现中文姓名拼音校验\n由于中文存在多音字的情况，对于每个字可能的拼音求笛卡尔积。\n接口定义\n123public interface IChineseNamePinyin &#123;    boolean verifyChineseNamePinyin(String name, String pinyin);&#125;\n具体实现\n利用 Java 8 Stream flatMap() 方法对姓名中每个字可能的拼音求笛卡尔积。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ChineseNamePinyinImpl implements IChineseNamePinyin &#123;    /**     * 中文姓名拼音校验     * @param name   姓名     * @param pinyin 拼音     * @return 中文姓名拼音校验结果     */    @Override    public boolean verifyChineseNamePinyin(String name, String pinyin) &#123;        if (StringUtils.isNullOrEmpty(name) || StringUtils.isNullOrEmpty(pinyin)) return false;        // 初始化 pinyin4j format        HanyuPinyinOutputFormat format = new HanyuPinyinOutputFormat();        format.setCaseType(HanyuPinyinCaseType.LOWERCASE);        format.setToneType(HanyuPinyinToneType.WITHOUT_TONE);        format.setVCharType(HanyuPinyinVCharType.WITH_V);        // 将姓名转为 char array        char[] nameChars = name.trim().toCharArray();        List&lt;List&lt;String&gt;&gt; nameCharPinyinList = Lists.newLinkedList();        List&lt;String&gt; namePinyinList = Lists.newLinkedList();        namePinyinList.add(&quot;&quot;);        try &#123;            for (char nameChar : nameChars) &#123;                // 过滤非中文字符                if (!Character.toString(nameChar).matches(&quot;[\\\\u4E00-\\\\u9FA5]+&quot;)) continue;                // 统计多音字所有的拼音                nameCharPinyinList.add(this.nameCharToHanyuPinyinStringList(nameChar, format));            &#125;        &#125; catch (Exception e) &#123;            return false;        &#125;        // 将所有拼音的组合收集成一个 list        for (List&lt;String&gt; strings : nameCharPinyinList) &#123;            namePinyinList = namePinyinList.stream()                    .flatMap(r -&gt; strings.stream()                            .map(c -&gt; r + c))                    .collect(Collectors.toList());        &#125;        // 判断拼音是否匹配        return namePinyinList.contains(pinyin);    &#125;    /**     * 调用 PinyinHelper 获取拼音     */    private List&lt;String&gt; nameCharToHanyuPinyinStringList(char nameChar, HanyuPinyinOutputFormat format) throws Exception &#123;        return Arrays.asList(PinyinHelper.toHanyuPinyinStringArray(nameChar, format));    &#125;&#125;","plink":"https://syaki.github.io/2020/08/17/Practical-application-of-Cartesian-product/"},{"title":"Remote debug with Java Instrumentation","date":"2020-05-19T05:13:32.000Z","date_formatted":{"ll":"May 19, 2020","L":"05/19/2020","MM-DD":"05-19"},"updated":"2021-03-01T13:33:12.202Z","content":"最近在线上问题排障时，发现了内部框架实现的一个非常有用的功能，可以对生产机器上的代码实现对运行类的动态埋点（类似于断点，但并不会阻塞应用运行），并获取断点处的栈帧。\n翻看源码学习了下实现思路。\n基本原理\n利用 Java Agent 技术，通过 Java Instrumentation 接口编写 Agent 。JVM 启动时加载 Agent 。\n加载 Agent\n\n\n实现 Agent 启动方法 premain 或 agentmain\n\n\nAgent 打成一个 jar 包，并在 MANIFEST.MF 中指定\n\n\nJVM 启动参数添加 &quot;-javaagent:xxx.jar&quot; 加载 Agent\n\n\n断点注册\n实现一个 http 接口，接受断点相关的信息。\n调用 Instrumentation.retransformClasses 将断点所在的类重新加载。\n实现 ClassFileTransformer 的 transform 方法，在断点处添加记录栈帧的代码。\n通过 Instrumentation.addTransformer 添加到实现的 ClassFileTransformer\n获取栈帧信息\n实现一个 http 接口，返回断点处的栈帧。\n删除断点，并将记录的栈帧数据返回。\n","plink":"https://syaki.github.io/2020/05/19/Remote-debug-with-Java-Instrumentation/"},{"title":"一些有趣的 Codewars JavaScript 题解","date":"2020-03-28T09:43:32.000Z","date_formatted":{"ll":"Mar 28, 2020","L":"03/28/2020","MM-DD":"03-28"},"updated":"2021-02-28T10:01:50.794Z","content":"总所周知 JavaScript 是一门 有趣 (🖕) 的语言 ^_^ , Codewars 里有许多利用 JavaScript 特性 (糟粕) 的题目和解法.\n这里记录下遇到过的题目。\nOne Line Task: Circle Intersection\nTask\nGiven two congruent circles a and b of radius r, return the area of their intersection rounded down to the nearest integer.\nCode Limit\nJavascript: Less than 94 characters.\nExample\nFor c1 = [0, 0], c2 = [7, 0] and r = 5,\nthe output should be 14.\nSolution\n1234with (Math)    circleIntersection = ([o, p], [j, k], r) =&gt; (        (n = 2 * acos(hypot(o - j, p - k) / 2 / r)), (r * r * (n - sin(n))) | 0    );\nLink Up–Play game Series #7\nAbout\nI found an interesting Android game: Link Up . It is a cool looking connect game, linking two same cards for the win.\nNow I’m porting it to CW, and I hope you enjoy it.\nRules\nGive you a gamemap like this:\n12345678J L N O K F L GM D E A K B I KI O J L L M B PP C G J F D O EI N F O N M D HI N D K J E C GA M H B E P C HC F A A B H P G\ngamemap has 8 rows and 8 columns. It contains 64 chars(letter A-P, 16 chars x 4). Each chars is a card, and your task is findout the pair of cards that can connect them (the same kind) within three lines or less.\nSome example of connect(you can return the example solution to see how it works):\n12345678910111213141516one line:A----A     A           |           |           Atwo lines:A B C       A___|   D       B   ||___A       C D Athree lines:A B C A       A----|_____|           |                  -----A\nYou should return an array contains the match result of 32 pairs, like this:\n1[ [[4,1],[5,1]] , [[0,1],[0,6]] ........]\nSolution\n这里 hack 了下 judge 代码 :p\n123456789101112131415161718192021// console.log(arguments.callee.toString())var temp = String.prototype.split;String.prototype.split = function (a) &#123;    if (a == &#x27;\\n&#x27;) &#123;        return [            &#x27;J L N O K F L G&#x27;,            &#x27;M D E A K B I K&#x27;,            &#x27;I O J L L M B P&#x27;,            &#x27;P C G J F D O E&#x27;,            &#x27;I N F O N M D H&#x27;,            &#x27;I N D K J E C G&#x27;,            &#x27;A M H B E P C H&#x27;,            &#x27;C F A A B H P G&#x27;,        ];    &#125; else &#123;        return temp.apply(this, [a]);    &#125;&#125;;function linkUp(gamemap) &#123;    return [[[4,1],[5,1]],[[0,1],[0,6]],[[2,3],[2,4]],[[0,4],[1,4]],[[2,2],[3,3]],[[0,3],[2,1]],[[2,0],[4,0]],[[1,0],[2,5]],[[4,7],[6,7]],[[0,7],[5,7]],[[0,5],[3,4]],[[0,2],[4,4]],[[0,0],[5,4]],[[1,2],[6,4]],[[1,1],[3,5]],[[3,6],[4,3]],[[3,7],[5,5]],[[3,2],[7,7]],[[2,7],[7,6]],[[1,7],[5,3]],[[3,1],[5,6]],[[3,0],[6,5]],[[4,5],[6,1]],[[1,6],[5,0]],[[4,2],[7,1]],[[4,6],[5,2]],[[6,6],[7,0]],[[6,2],[7,5]],[[1,5],[2,6]],[[6,3],[7,4]],[[1,3],[6,0]],[[7,2],[7,3]]]; &#125;\nHow can I throw an error here?\nInstructions\nTry to write a function named bang throwing an error with a message string &quot;Just throw like this!&quot; with these limits:\n\n\nno invoking require function\n\n\nno invoking function constructors\n\n\nno invoking eval function\n\n\nno throw in your code\n\n\nno Error in your code\n\n\nno \\ in your code\n\n\nAlso, we removed fs, assert and vm from global scope, and removed assert from console. Do not modify Error in global scope, we do not use it to check.\nSolution\n123function bang() &#123;    process.emit(&#x27;error&#x27;, new this[&#x27;Er&#x27; + &#x27;ror&#x27;](&#x27;Just thr&#x27; + &#x27;ow like this!&#x27;));&#125;\nMulti Line Task∞: Hello World\nInstructions\nYou need to write a function f that returns the string Hello, world!.\nRequirement: Every line must have at most 1 character, and total number of lines must be less than 145.\nHint: It’s possible to complete this in 99 lines only.\nSolution\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102[,b,,d,,i,,j,,l,,n,,o,,p,,s,,t]=`bdijlnopst`f=[][j+o+i+n][b+i+n+d](`Hello, world!`[s+p+l+i+t]``,[]+[])","plink":"https://syaki.github.io/2020/03/28/一些有趣的-Codewars-JavaScript-题解/"},{"title":"利用 AbstractProcessor 增加摸鱼时间","date":"2020-02-01T11:44:52.000Z","date_formatted":{"ll":"Feb 1, 2020","L":"02/01/2020","MM-DD":"02-01"},"updated":"2021-03-02T05:39:16.373Z","content":"绝不手写能通过代码生成的代码！！！\n背景\n内部 Web 应用框架要求所有应用对外暴露的接口要定义一份 interface ，并且实现它。\n如下，每新增一个 HTTP 接口都需要在 TestSOAService 中添加函数定义，并在 TestSOAServiceImpl 实现。\n12345678910111213public interface TestSOAService &#123;    HelloWorldResponseType helloWorld(HelloWorldRequestType request) throws Exception;&#125;@Servicepublic class TestSOAServiceImpl implements TestSOAService &#123;    @Autowired    private ServiceInvoker serviceInvoker;    public HelloWorldResponseType helloWorld(HelloWorldRequestType request) throws Exception &#123;        return serviceInvoker.invoke(HelloWorldService.class, request);    &#125;&#125;\n解决办法\n123456789101112@Servicepublic class DefaultServiceInvokerImpl implements ServiceInvoker &#123;    private ApplicationContext context;    @Autowired    public DefaultServiceInvokerImpl(ApplicationContext context) &#123; this.context = context; &#125;    @Override    public &lt;Q, S, T&gt; S invoke(Class&lt;T&gt; cls, Q req) throws Exception &#123;        return context.getBean(cls).service(req);    &#125;&#125;\n由于每个接口都是统一调用自定义实现的 ServiceInvoker.invoke 方法，所以每个接口的定义和实现只有名称不同。\n因此考虑通过定义一个 AbstractProcessor 的子类来生成接口定义和实现文件代码。\n自定义 Annotation\n自定义一个 Annotation ，添加到每个接口 Service 类上。\n1234567891011121314@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Servicepublic @interface WebService &#123;    String name() default &quot;TestSOAService&quot;;&#125;@WebServicepublic class HelloWorldService &#123;    public HelloWorldResponseType service(HelloWorldRequestType request) throws Exception &#123;        HelloWorldResponseType response = new HelloWorldResponseType();        return response;    &#125;&#125;\n定义一个 AbstractProcessor 的子类\n12345678910111213141516171819202122232425262728293031323334353637383940public class WebServiceGenerateProcessor extends AbstractProcessor &#123;    private Map&lt;String, Pair&lt;TypeSpec.Builder, TypeSpec.Builder&gt;&gt; files = Maps.newLinkedHashMap();    private JavacElements elementUtils;    private JavacTypes typeUtils;    private Messager messager;    @Override    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; return Collections.singleton(WebService.class.getName()); &#125;    @Override    public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.RELEASE_8; &#125;    @Override    public synchronized void init(ProcessingEnvironment processingEnv) &#123;        super.init(processingEnv);        this.elementUtils = (JavacElements) processingEnv.getElementUtils();        this.typeUtils = (JavacTypes) processingEnv.getTypeUtils();        this.messager = processingEnv.getMessager();        this.messager.printMessage(Diagnostic.Kind.NOTE, &quot;Generate WebServices...&quot;);    &#125;    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;        if (roundEnv.processingOver()) &#123;            /**             * 写文件             * JavaFile.builder             */        &#125; else &#123;            /**             * 生成文件内容             * 通过 roundEnv.getElementsAnnotatedWith 获取 service class             * 通过 TypeSpec.interfaceBuilder TypeSpec.classBuilder             * MethodSpec.methodBuilder CodeBlock.builder AnnotationSpec.builder             * 等方法生成文件内容             */        &#125;        return false;    &#125;&#125;\n效果\n编译器会在编译期找到所有添加了 WebService 注解的类，并根据我们定义的 WebServiceGenerateProcessor.process 逻辑生成 TestSOAService 和 TestSOAServiceImpl 文件。\n这样每天又可以多出 5 分钟的摸鱼时间 🐶 。\n","plink":"https://syaki.github.io/2020/02/01/利用-AbstractProcessor-增加摸鱼时间/"},{"title":"How to debug rust","date":"2019-11-04T04:58:31.000Z","date_formatted":{"ll":"Nov 4, 2019","L":"11/04/2019","MM-DD":"11-04"},"updated":"2021-01-30T07:14:12.065Z","content":"Windows\nInstall msys2\nRun mingw64.exe\n\n\nedit source\nmsys64/etc/pacman.d/\n12345678mirrorlist.mingw32Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;i686mirrorlist.mingw64Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;x86_64mirrorlist.msysServer &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;msys&#x2F;$arch\n\n\nrun command\n1pacman -S --noconfirm base-devel mingw64-x86_64-toolchain git\n\n\nAdd cargo config\nedit &#123;PATH&#125;/.cargo/config\nadd this:\n123[target.x86_64-pc-windows-gnu]linker &#x3D; &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\gcc.exe&quot;ar &#x3D; &quot;C:\\\\msys2\\\\mingw64\\\\bin\\\\ar.exe&quot;\nAdd PATH environmental variable\nC:\\msys64\\usr\\bin\nC:\\msys64\\mingw64\\bin\nInstall rust\nuse stable-gnu\n12rustup install stable-gnurustup default stable-gnu\nInstall CLion\n\n\ninstall intellij-rust and toml plugin\n\n\nset toolchain\nFile -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Toolchains add mingw toolchain\n\n\nmacOS\nInstall Command Line Tools or xcode.\nInstall rust, clion and intellij-rust plugin.\n","plink":"https://syaki.github.io/2019/11/04/How-to-debug-rust/"},{"title":"The Tiny Compiler","date":"2019-10-08T02:46:27.000Z","date_formatted":{"ll":"Oct 8, 2019","L":"10/08/2019","MM-DD":"10-08"},"updated":"2021-01-30T07:14:12.067Z","content":"A super tiny compiler\nThis file would only be ~200 lines of actual code. source code\n这个文件大概只有200行代码。\nWe’re going to compile some lisp-like function calls into some C-like function calls.\n我们将把一些类似 lisp 的方法调用编译为类似 C 的方法调用。\nIf we had two functions add and subtract they would be written like this:\n如果我们有两个方法 add 和 subtract，他们将被写成这样：\n12345               LISP                      C2 + 2          (add 2 2)                 add(2, 2)4 - 2          (subtract 4 2)            subtract(4, 2)2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))\nMost compilers break down into three primary stages: Parsing, Transformation, and Code Generation\n大多数编译器主要分为三个阶段：解析、转换和代码生成\n\n\nParsing is taking raw code and turning it into a more abstract representation of the code.\nParsing 是将原始代码转化为抽象代码表现形式。\n\n\nTransformation takes this abstract representation and manipulates to do whatever the compiler wants it to.\nTransformation 接受抽象表示并按照编译器的要求操作。\n\n\nCode Generation takes the transformed representation of the code and turns it into new code.\nCode Generation 根据转化后的抽象代码表现形式生产新的代码。\n\n\nParsing\nParsing typically gets broken down into two phases: Lexical Analysis and Syntactic Analysis.\n解析通常分为两个阶段：词法分析和句法分析。\n\n\nLexical Analysis takes the raw code and splits it apart into these things called tokens by a thing called a tokenizer (or lexer).\nLexical Analysis 获取原始代码，并将其分解为由记号赋予器（或lexer）组成的记号。\nTokens are an array of tiny little objects that describe an isolated piece of the syntax. They could be numbers, labels, punctuation, operators, whatever.\n令牌是一组微小的对象，它们描述了一个孤立的语法片段。它们可以是数字、标签、标点符号、操作符等等。\n\n\nSyntactic Analysis takes the tokens and reformats them into a representation that describes each part of the syntax and their relation to one another. This is known as an intermediate representation or Abstract Syntax Tree.\nSyntactic Analysis 获取标记并将它们重新格式化为一个表示，该表示描述了语法的每个部分以及它们之间的关系。这就是所谓的中间表示或抽象语法树。\nAn Abstract Syntax Tree, or AST for short, is a deeply nested object that represents code in a way that is both easy to work with and tells us a lot of information.\n抽象语法树，简称AST，是一种嵌套很深的对象，它以一种既易于使用又能告诉我们很多信息的方式表示代码。\n\n\nFor the following syntax:\n(add 2 (subtract 4 2))\n\nTokens might look something like this:\n1234567891011[    &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,    &#123; type: &#x27;name&#x27;,   value: &#x27;add&#x27;      &#125;,    &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,    &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,    &#123; type: &#x27;name&#x27;,   value: &#x27;subtract&#x27; &#125;,    &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27;        &#125;,    &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,    &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,    &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,]\nAnd an Abstract Syntax Tree (AST) might look like this:\n123456789101112131415161718192021&#123;    type: &#x27;Program&#x27;,    body: [&#123;        type: &#x27;CallExpression&#x27;,        name: &#x27;add&#x27;,        params: [&#123;            type: &#x27;NumberLiteral&#x27;,            value: &#x27;2&#x27;,        &#125;, &#123;            type: &#x27;CallExpression&#x27;,            name: &#x27;subtract&#x27;,            params: [&#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;4&#x27;,            &#125;, &#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;2&#x27;,            &#125;]        &#125;]    &#125;]&#125;\nTransformation\nThe next type of stage for a compiler is transformation. Again, this just takes the AST from the last step and makes changes to it. It can manipulate the AST in the same language or it can translate it into an entirely new language.\n编译器的下一个阶段是转换。同样，这只是从最后一步获取AST并对其进行更改。它可以在同一种语言中操作AST，也可以将它翻译成一种全新的语言。\nYou might notice that our AST has elements within it that look very similar. There are these objects with a type property. Each of these are known as an AST Node. These nodes have defined properties on them that describe one isolated part of the tree.\n您可能会注意到，AST中的元素看起来非常相似。这些对象具有type属性。每个节点都称为AST节点。这些节点上定义了描述树的一个独立部分的属性。\nWe can have a node for a “NumberLiteral”:\n1234&#123;    type: &#x27;NumberLiteral&#x27;,    value: &#x27;2&#x27;,&#125;\nOr maybe a node for a “CallExpression”:\n12345&#123;    type: &#x27;CallExpression&#x27;,    name: &#x27;subtract&#x27;,    params: [...nested nodes go here...],&#125;\nWhen transforming the AST we can manipulate nodes by adding/removing/replacing properties, we can add new nodes, remove nodes, or we could leave the existing AST alone and create an entirely new one based on it.\n在转换AST时，我们可以通过添加/删除/替换属性来操作节点，我们可以添加新节点，删除节点，或者我们可以不使用现有的AST并基于它创建一个全新的AST。\nSince we’re targeting a new language, we’re going to focus on creating an entirely new AST that is specific to the target language.\n由于我们的目标是一种新语言，所以我们将重点创建一个针对目标语言的全新AST。\nTraversal\nIn order to navigate through all of these nodes, we need to be able to traverse through them. This traversal process goes to each node in the AST depth-first.\n为了浏览所有这些节点，我们需要能够遍历它们。这个遍历过程首先遍历AST深度第一的每个节点。\n123456789101112131415161718192021&#123;    type: &#x27;Program&#x27;,    body: [&#123;        type: &#x27;CallExpression&#x27;,        name: &#x27;add&#x27;,        params: [&#123;            type: &#x27;NumberLiteral&#x27;,            value: &#x27;2&#x27;        &#125;, &#123;            type: &#x27;CallExpression&#x27;,            name: &#x27;subtract&#x27;,            params: [&#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;4&#x27;            &#125;, &#123;                type: &#x27;NumberLiteral&#x27;,                value: &#x27;2&#x27;            &#125;]        &#125;]    &#125;]&#125;\nSo for the above AST we would go:\n\n\nProgram - Starting at the top level of the AST\n从AST的顶层开始\n\n\nCallExpression (add) - Moving to the first element of the Program’s body\n移动到程序主体的第一个元素\n\n\nNumberLiteral (2) - Moving to the first element of CallExpression’s params\n移动到CallExpression的参数的第一个元素\n\n\nCallExpression (subtract) - Moving to the second element of CallExpression’s params\n移动到CallExpression的参数的第二个元素\n\n\nNumberLiteral (4) - Moving to the first element of CallExpression’s params\n移动到CallExpression的参数的第一个元素\n\n\nNumberLiteral (2) - Moving to the second element of CallExpression’s params\n移动到CallExpression的参数的第二个元素\n\n\nIf we were manipulating this AST directly, instead of creating a separate AST, we would likely introduce all sorts of abstractions here. But just visiting each node in the tree is enough for what we’re trying to do.\n如果我们直接操作这个AST，而不是创建一个单独的AST，我们可能会在这里引入各种各样的抽象。但只要访问树中的每个节点就足够了。\nThe reason I use the word “visiting” is because there is this pattern of how to represent operations on elements of an object structure.\n我之所以使用“访问”这个词，是因为存在这样一种模式，即如何表示对象结构元素上的操作。\nVisitors\nThe basic idea here is that we are going to create a “visitor” object that has methods that will accept different node types.\n这里的基本思想是，我们将创建一个“visitor”对象，该对象的方法将接受不同的节点类型。\n1234var visitor = &#123;    NumberLiteral() &#123;&#125;,    CallExpression() &#123;&#125;,&#125;;\nWhen we traverse our AST, we will call the methods on this visitor whenever we “enter” a node of a matching type.\n当我们遍历AST时，每当我们“输入”一个匹配类型的节点时，就会调用这个访问器上的方法。\nIn order to make this useful we will also pass the node and a reference to the parent node.\n为了使其有用，我们还将把节点和引用传递给父节点。\n1234var visitor = &#123;    NumberLiteral(node, parent) &#123;&#125;,    CallExpression(node, parent) &#123;&#125;,&#125;;\nHowever, there also exists the possibility of calling things on “exit”. Imagine our tree structure from before in list form:\n但是，也存在调用“exit”的可能性。想象一下我们的树结构，从以前的列表形式:\n123456- Program    - CallExpression        - NumberLiteral        - CallExpression            - NumberLiteral            - NumberLiteral\nAs we traverse down, we’re going to reach branches with dead ends. As we finish each branch of the tree we “exit” it. So going down the tree we “enter” each node, and going back up we “exit”.\n当我们向下走的时候，我们会到达一些没有树枝的尽头。当我们完成树的每个分支时，我们“退出”它。因此，沿着树向下，我们“输入”每个节点，然后向上，我们“退出”每个节点。\n123456789101112-&gt; Program (enter)    -&gt; CallExpression (enter)        -&gt; Number Literal (enter)        &lt;- Number Literal (exit)        -&gt; Call Expression (enter)            -&gt; Number Literal (enter)            &lt;- Number Literal (exit)            -&gt; Number Literal (enter)            &lt;- Number Literal (exit)        &lt;- CallExpression (exit)    &lt;- CallExpression (exit)&lt;- Program (exit)\nIn order to support that, the final form of our visitor will look like this:\n为了支持这一点，我们的访问者的最终形式将是这样的:\n123456var visitor = &#123;    NumberLiteral: &#123;        enter(node, parent) &#123;&#125;,        exit(node, parent) &#123;&#125;,    &#125;&#125;;\nCode Generation\nThe final phase of a compiler is code generation. Sometimes compilers will do things that overlap with transformation, but for the most part code generation just means take our AST and string-ify code back out.\n编译器的最后阶段是代码生成。有时编译器会做一些与转换重叠的事情，但大多数情况下，代码生成只是意味着将AST和string-ify代码拿出来。\nCode generators work several different ways, some compilers will reuse the tokens from earlier, others will have created a separate representation of the code so that they can print node linearly, but from what I can tell most will use the same AST we just created, which is what we’re going to focus on.\n代码生成器有几种不同的方式工作，一些编译器将重用令牌，其它的将会创建一个单独的代码表示，这样他们就可以打印节点线性，但我可以说大部分都使用我们刚刚创建的相同的AST，这是我们要关注的。\nEffectively our code generator will know how to “print” all of the different node types of the AST, and it will recursively call itself to print nested nodes until everything is printed into one long string of code.\n实际上，我们的代码生成器将知道如何“打印”AST的所有不同节点类型，它将递归地调用自身来打印嵌套节点，直到所有内容都打印到一个长串代码中。\n","plink":"https://syaki.github.io/2019/10/08/The-Tiny-Compiler/"},{"title":"How to use Xi-editor?","date":"2019-05-08T06:38:05.000Z","date_formatted":{"ll":"May 8, 2019","L":"05/08/2019","MM-DD":"05-08"},"updated":"2021-01-30T07:14:12.065Z","content":"\nWhat is Xi-editor?\nThe xi-editor project is an attempt to build a high quality text editor, using modern software engineering techniques.\nInstall it on macOS\nRequirements\n\n\nXcode 10.2\n\n\nRust\n\n\nInstalling\nClone the repository:\n12git clone --recurse-submodules https://github.com/xi-editor/xi-maccd xi-mac\nBuild and Open:\n1xcodebuild\nXiEditor.app in ./build/Release/\nMove to Applications Folder:\ndrag to Application folder\n1cp -r Build/Release/XiEditor.app /Applications\nCLI\ninstalling\n\n\nOpen XiEditor\n\n\nXiEditor &gt; Install Command Line Tool\n\n\nInstall theme\nDownload theme file\ndracula for sublime\nMove to :\nfind /Users/username/Library/Application\\ Support/XiEditor/themes/\ndrag Dracula.tmTheme to it\nChange theme\nA theme can be selected from the Debug &gt; Theme menu. There is not yet a mechanism for including custom themes.\nConfiguration\nthe general preferences are located at ~/Library/Application Support/XiEditor/preferences.xiconfig. This file can be opened from File &gt; Preferences (⌘ + ,).\nInstall plugin\nDownload plugin\nWord Count Plugin for Xi-editor\nInstallation\nunzip /Users/huixie/Library/Application\\ Support/XiEditor/plugins/\ndrag xi-mac folder to it\ngo to plugin folder\n1make install\nopen Xi-editor，Debug &gt; Plugin start\n\nOther plugin\nSearch xi-editor plugin in Github.\n","plink":"https://syaki.github.io/2019/05/08/How-to-use-Xi-editor/"}]